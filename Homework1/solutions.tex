\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage[hidelinks, colorlinks = true, urlcolor = blue, citecolor = black]{hyperref}

%opening
\title{Homework 1\\
	\large Algorithm Design 2018-19 - Sapienza}
\author{Luigi Russo 1699981}

\begin{document}
	
\maketitle

\section{Cristina and centers}
Cristina is interested in a metric space (X, d), where all distances d(x, y) are
either 0 (in which case x = y), 1 or 3. Further, all distances are symmetric and obey the triangle inequality, that is $d(a, b) + d(b, c) >= d(a, c)$. Cristina wants to cluster the points of X. Unfortunately, she does not yet know how many clusters she has to use. She therefore will find a permutation $\Pi(X)$ and use, for every $k \in \{1, ..., |X|\}$, the first k elements $C =
{\pi(X)_1, ..., \pi(X)_k}$ of the permutation as centers.
\paragraph*{Goal:} For any such k, the output should be optimal with respect to following objective function:
\begin{equation}
\max_{x \in X} \min_{c \in C} d(x,c).
\end{equation}
\paragraph*{Hint:} Use a greedy algorithm. The running time should be no larger than $O(|X|^2)$

\subsection*{Solution algorithm}
This problem can be seen as a variant of the well-known K-centers decision problem. I have designed a greedy algorithm that solves the above problem.
It creates (and returns to Cristina) the desired permutation in this way.
\begin{enumerate}
	\item $C:= \emptyset$
	\item pick a random point c1
	\item for every point v $in$ V, compute distance from c1 to v 
	\item pick the point c2 with highest distance from the points in C
	\item add c2 to C and continue until $|V| = |C|$
\end{enumerate}

\subsection*{Running time}
The algorithm adds $|X|$ points to C. How much costs adding a point to C? A point is added to C if among all the points not in C it has the maximum distance from the ones in C. At each iteration we update the minimum distance from all points to C, simply considering if the new center can "decrease" the distance. It costs $|X - 1|$ for the second center, $|X - 2|$ for the third... so it's never greater than $|X|$. Since the iterations are $|X|$ and each one costs $|X|$ we have the cost is $|X^2|$
\subsection*{Proof of correctness}
At each iteration the algorithm updates (if possible) the current maximum\_distance from the set of centers. This leads to a non increasing sequence of max\_values = ${d_1, d_2, ... d_{|V|}}$. Given an optimal solution O, we have to prove that the sequence computed with the greedy algorithm above is such that for every $i \in {1, 2, ... |V|}$, $dg\_i = do_i $, where $dg$ is the sequence of max distances of the greedy algorithm and do the one of the optimal algorithm. Since my greedy algorithm guarantees that for every k, $dg_k \leq 2* do_k$ and since the only possible values of d are 0, 1 or 3, we have these possible cases:
$do_k = 0 =>  do_k = 0 \leq dg_k \leq 2* 0 = 0 => dg_k = 0 OK$
$do_k = 1 =>  do_k = 1 \leq dg_k \leq 2* 1 = 2 => dg_k = 1 OK$, since 2 is not a possible value.
$do_k = 3 =>  do_k = 3 \leq dg_k \leq 2* 3 = 6 => dg_k = 3 OK$, since 3 is the only value greater or equal than 3 and less or equal than 3.
This is true for every k. We have that the greedy algorithm computes as well as the optimal solution.

\section{Streets and avenues}
Use the Vertex Cover for Bipartite graph. This NP problem can be solve in polynomial time with a simple algorithm. First find a matching on the bipartite graph. Then create the set Z = all nodes not reached by the matching. Then add to Z all nodes that can be reached by Z with an alternating path (non-matching and matching!). Then return the set of nodes \ Z.
\section{}
\section{}
\section{Federico and MST}
Federico is a mathematician who doesn't like stories and wants the exercise to get to the point.
\newline
\textbf{Goal:} We are given a weighted graph G(V, E). Let e $\in$ E.
\begin{enumerate}
	\item Design an algorithm that decides whether or not there exists a minimum spanning tree containing e. For full marks, the algorithm must run in time at most $O(|V | + |E|)$.
	\item Design an algorithm that computes a minimum spanning tree containing e, if one exists. For full marks, the algorithm must run in time at most $O(|E| log |E|)$. Implement the algorithm with a programming language of your choice.

\end{enumerate}
\subsection{}
Given e = (u,v):
\begin{enumerate}
	\item run a DFS from the endpoint u \textbf{considering only those edges that have weight less than that of e}.
	\item Two possible cases:
	\begin{enumerate}
		\item If during the DFS there is an edge that leads to node v, then the edge e does not belong to any MST.
		\item If the DFS terminates and case 1 never happens, then there exist some MST that contains e.
	\end{enumerate}
\end{enumerate}

\subsubsection{Source code}
See next sections.

\subsubsection{Proof of correctness}
I have used the MST cycle property in this way: we know that given a cycle in a graph, the largest edge among the ones that form the cycle cannot belong to a MST. So, the DFS run above tries to connect \textit{u} and \textit{v} with edges \textbf{strictly lower} than \textit{e}: if this happens, it means that there exist some cycle in the graph that connects \textit{u} and \textit{v} and, of course, such cycle contains the edge e: since all the edges considered during our \textit{custom} DFS are strictly lower than \textit{e}, we can conclude that \textit{e} is the largest edge in a cycle of the graph. So, by the MST cycle property, \textit{e} cannot belong to any MST. Since this condition is necessary and sufficient, this is enough for our proof.

\subsection{}
\begin{enumerate}
	\item Run the algorithm 5.1: if \textit{e} cannot belong to any MST throw an error.
	\item Run a \textit{custom} Boruvka, whit all disconnected components, except \textit{u} and \textit{v}: we connect them since the beginning adding edge \textit{e} to the MST.
\end{enumerate}

\subsubsection{Code}
I have implemented the exercise in Python language, using networkx library for graph management (add nodes, get adjacent nodes, etc.). The code is attached as ex5.py.

\subsubsection{Proof of correctness}
The algorithm 5.1 is able to verify that a MST with edge \textit{e} really exists. Once we know that such MST can be built, we run a custom version of Boruvka algorithm. Since we know that a MST with edge \textit{e} exists, we also know that \textit{u} and \textit{v} belong to the same connected component; moreover, we know that the edge \textit{e} must be part of the MST and \textit{e} is the edge (the only one of course in the MST we compute) that has to connect \textit{u} and \textit{v}. So we start Boruvka initializing all the nodes (except \textit{u} and \textit{v}) as disconnected components: as for \textit{u} and \textit{v}, we bind them to the same connected component (with edge \textit{e}). Now, Boruvka algorithm will run and produce a MST: we can be sure about that because this algorithm is designed to find a MST starting from a forest of disconnected components. \textbf{Note:} The algorithm will fail if the graph is not connected actually, but we can assume the graph is always connected, or we can check easily at the end of the algorithm if the current MST is really a tree: the number of edges \textit{returned} must be n-1. 

\end{document}