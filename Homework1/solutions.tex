\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage[hidelinks, colorlinks = false]{hyperref}

%opening
\title{Homework 1\\
	\large Algorithm Design 2018-19 - Sapienza}
\author{Luigi Russo 1699981}

\begin{document}
	
\maketitle

\newpage
\tableofcontents
\newpage


\section{Cristina and centers}
Cristina is interested in a metric space (X, d), where all distances d(x, y) are
either 0 (in which case x = y), 1 or 3. Further, all distances are symmetric and obey the triangle inequality, that is $d(a, b) + d(b, c) >= d(a, c)$. Cristina wants to cluster the points of X. Unfortunately, she does not yet know how many clusters she has to use. She therefore will find a permutation $\Pi(X)$ and use, for every $k \in \{1, ..., |X|\}$, the first k elements $C =
{\pi(X)_1, ..., \pi(X)_k}$ of the permutation as centers.
\paragraph*{Goal:} For any such k, the output should be optimal with respect to following objective function:
\begin{equation}
\max_{x \in X} \min_{c \in C} d(x,c).
\end{equation}
\paragraph*{Hint:} Use a greedy algorithm. The running time should be no larger than $O(|X|^2)$

\subsection{The algorithm}
This problem can be seen as a variant of the well-known K-centers decision problem. I have designed a greedy algorithm that solves the above problem.
It creates (and returns to Cristina) the desired permutation in this way.
\begin{enumerate}
	\item $C:= [\,]$
	\item pick a random point c1 and add it to the list of centers C.
	\item for every point v $\in$ V (v $\notin C$), compute the minimum distance from C to v 
	\item pick the point c2 with highest distance from the points in C
	\item add c2 to C and continue the process until $|V| = |C|$
\end{enumerate}

\subsubsection{Running time}
The algorithm adds $|X|$ points to C. How much costs adding a point to C? A point is added to C if, among all the points v $\notin$ C, it has the maximum distance from the ones in C. At each iteration we update the minimum distance from all points to C, simply considering if the new center can "decrease" the current distance of the point from C. It costs $|X - 1|$ for the second center, $|X - 2|$ for the third and so on. Since the iterations are $|X|$ and each one costs $O(|X|)$ we have the cost is $O(|X^2|)$
\subsubsection{Proof of correctness}
At each iteration the algorithm updates (if possible) the current maximum distance from the list of centers. This leads to a non increasing sequence of max\_values = ${d_1, d_2, ... d_{|X|}}$. Given an optimal solution O, we have to prove that the sequence computed with the greedy algorithm above is such that for every $i \in {1, 2, ... |X|}$, $d_g[i] = d_o[i] $, where $d_g[i]$ is the maximum distance from C in the greedy algorithm and $d_o[i]$ is the maximum distance from C in the optimal solution. Since my greedy algorithm guarantees that for every k, $d_g[k] \leq 2* d_o[k]$ and since the only possible values of d are 0, 1 or 3, we have these possible cases:
\begin{itemize}
	\item $d_o[k] = 0 \Rightarrow  0 \leq d_g[k] \leq 2\cdot0 = 0 \Rightarrow d_g[k] = 0$ OK
	\item $d_o[k] = 1 \Rightarrow  1 \leq d_g[k] \leq 2\cdot1 = 2 \Rightarrow d_g[k] = 1 $, OK since 1 is the only value that d can assume s.t. $1 \leq d \leq 2$
	\item $d_o[k] = 3 \Rightarrow  3 \leq d_g[k] \leq 2\cdot3 = 6 \Rightarrow d_g[k] = 3 $, OK since 3 is the only value that d can assume s.t. $3 \leq d \leq 6$
\end{itemize}
And this is true for every k.

\section{Streets and avenues}
Consider a city with m parallel horizontal streets and n parallel vertical avenues.
These lines cross in $m \times n$ intersections. On $k \in \{1, ... ,m \times n\}$ of these intersections, special checkpoints are placed. We want to place video cameras on a subset of the streets and of the avenues such that each checkpoint is in the visibility range of a camera. A camera allows to monitor all the checkpoints of an avenue or of a street. The subset of may contain both
horizontal streets and vertical avenues. Clearly, you can always select all m + n of these streets and avenues. The challenge therefore is to select a smallest subset of these streets and avenues such that each checkpoint is in the visibility range of a camera.

\subsection{The algorithm}
\begin{enumerate}
	\item Consider the starting grid as the biadjacency matrix of a graph $G = (S, A)$, where S is the set of the streets and A is the set of the avenues: each checkpoint marks the presence of an edge of capacity 1.
	\item Create a super-source node connected to all the nodes in S and a super-sink node connected to all the nodes in A. The capacity of each of these edges is set to 1. Call G' such a graph.
	\item Run Ford-Fulkerson algorithm to find the minimum-capacity cut C.
	\item Define $L1 := L \cap C$, $L2 := L - C$, $R1 := R \cap C$, $R2 := R - C$
	\item Let B be the set of nodes in R2, s.t. there is some edge from them to L1.
	\item Return as output the set $O:= L2 \cup R1 \cup B$
\end{enumerate}

\subsubsection{Running time}
Finding the minimum capacity cut in the first part costs only O(nm) if we use Ford Fulkerson. Once we compute the cut with minimum capacity we just have to make some intersections between L, R and C. In particular: L1 and L2 can be computed in O(m), R1 and R2 in O(n) and also B can be computed considering the edges between L1 and R2; remember that the maximum number of edges can be nm. So the total cost of the algorithm is bounded to O(nm).

\subsubsection{Proof of correctness}
The starting schema can be seen as the biadjacency matrix of a graph G = (S, A), where S is the set of the streets and A is the set of the avenues. Every checkpoint can be interpreted as an edge (u,v), with $u \in S$ and $v \in A$. What we want to find is the so called vertex cover, i.e. a set of nodes such that each edge of the graph has at least one endpoint in the set.
The output set O covers all edges that have an endpoint either in L2 or R1, because O includes all nodes of L2 and all nodes or R1. The nodes that have endpoint in L1 and the other endpoint in R2 are covered by B. This means that O covers all the nodes "involved" in the checkpoints. Moreover, there is no other set, with lower cardinality, that satisfies this property. In fact, Let k be the capacity of the minimum capacity cut. Then $k = |L2| + |R1| + |edges(L1,R2)|$ and so $k > |L2| + |R1| + |B| = |O|$. But k is equal to the capacity of the minimum cut in G', which is equal to the cost of the maximum flow in G' which is equal to the size of the maximum matching in G (for Konig theorem). This means that G has a matching of size k, and so every vertex cover must have size $>= k >= |O|$.
\section{Birtday NP}
Reduce to Crique problem.

\section{Hiring process}

\section{Federico and MST}
Federico is a mathematician who doesn't like stories and wants the exercise to get to the point.
\newline
\textbf{Goal:} We are given a weighted graph G(V, E). Let e $\in$ E.
\begin{enumerate}
	\item Design an algorithm that decides whether or not there exists a minimum spanning tree containing e. For full marks, the algorithm must run in time at most $O(|V | + |E|)$.
	\item Design an algorithm that computes a minimum spanning tree containing e, if one exists. For full marks, the algorithm must run in time at most $O(|E| log |E|)$. Implement the algorithm with a programming language of your choice.
\end{enumerate}

\subsection{The algorithm}
Given e = (u,v):
\begin{enumerate}
	\item run a DFS from the endpoint u \textbf{considering only those edges that have weight less than that of e}.
	\item Two possible cases:
	\begin{enumerate}
		\item If during the DFS there is an edge that leads to node v, then the edge e does not belong to any MST.
		\item If the DFS terminates and case 1 never happens, then there exist some MST that contains e.
	\end{enumerate}
\end{enumerate}

\subsubsection{Running time}
This is a simple variant of a DFS on a graph: the fact that we "filter" the edges can lead even to a reduction of visited nodes. In the worst case we know that DFS costs $O(|V| + |E|)$ and this is still the upper bound of algorithm 5.1.

\subsubsection{Source code}
See next sections.

\subsubsection{Proof of correctness}
I have used the MST cycle property in this way: we know that given a cycle in a graph, the largest edge among the ones that form the cycle cannot belong to a MST. So, the DFS run above tries to connect \textit{u} and \textit{v} with edges \textbf{strictly lower} than \textit{e}: if this happens, it means that there exist some cycle in the graph that connects \textit{u} and \textit{v} and, of course, such cycle contains the edge e: since all the edges considered during our \textit{custom} DFS are strictly lower than \textit{e}, we can conclude that \textit{e} is the largest edge in a cycle of the graph. So, by the MST cycle property, \textit{e} cannot belong to any MST. Since this condition is necessary and sufficient, this is enough for our proof.

\subsection{The algorithm}
\begin{enumerate}
	\item Run the algorithm 5.1: if \textit{e} cannot belong to any MST throw an error.
	\item Run a \textit{custom} Boruvka, whit all disconnected components, except \textit{u} and \textit{v}: we connect them since the beginning adding edge \textit{e} to the MST.
\end{enumerate}

\subsubsection{Running time}
The first part of the algorithm is run the 5.1, whose cost is $O(|V| + |E|)$. In the second part we perform a custom Boruvka, that is actually a Boruvka after a single union operation. This means that we can fix the bound of the algorithm to the well-known one of Boruvka: $O(|E| log|V|)$. If we assume that the graph is connected this is $\leq O(|E| log|E|)$.

\subsubsection{Source code}
I have implemented the exercise in Python language, using networkx library for graph management (add nodes, get adjacent nodes, etc.). The code is attached as ex5.py.

\subsubsection{Proof of correctness}
The algorithm 5.1 is able to verify that a MST with edge \textit{e} really exists. Once we know that such MST can be built, we run a custom version of Boruvka algorithm. Since we know that a MST with edge \textit{e} exists, we also know that \textit{u} and \textit{v} belong to the same connected component; moreover, we know that the edge \textit{e} must be part of the MST and \textit{e} is the edge (the only one of course in the MST we compute) that has to connect \textit{u} and \textit{v}. So we start Boruvka initializing all the nodes (except \textit{u} and \textit{v}) as disconnected components: as for \textit{u} and \textit{v}, we bind them to the same connected component (with edge \textit{e}). Now, Boruvka algorithm will run and produce a MST: we can be sure about that because this algorithm is designed to find a MST starting from a forest of disconnected components. \textbf{Note:} The algorithm will fail if the graph is not connected actually, but we can assume the graph is always connected, or we can check easily at the end of the algorithm if the current MST is really a tree: the number of edges \textit{returned} must be n-1. 

\end{document}